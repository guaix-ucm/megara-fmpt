// Copyright (c) 2012-2017 Isaac Morales Durán. All rights reserved.
// Institute of Astrophysics of Andalusia, IAA-CSIC
//
// This file is part of FMPT (Fiber MOS Positioning Tools)
//
// FMPT is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program.  If not, see <http://www.gnu.org/licenses/>.

//---------------------------------------------------------------------------
/// @file MotionProgramGenerator.h
/// @brief motion program generator
/// @author Isaac Morales Durán
//---------------------------------------------------------------------------

#ifndef MOTIONPROGRAMGENERATOR_H
#define MOTIONPROGRAMGENERATOR_H

#include "MotionProgramValidator.h"
#include "AllocationList.h"
#include "FMOSA.h"
#include "FiberMOSModel.h"
#include "MotionProgram.h"

using namespace Models;

//namespace for positioning
namespace Positioning {

//###########################################################################
//TMotionProgramGenerator:
//###########################################################################

/// @brief A MPG (Motion Program Generator) provide functions for generates MPs
/// (motion programs).
/// @brief For do this, the MPG shall use the FMM (Fiber MOS Model)
/// for perform simulations. All MPs  generated by the MPG will be valid,
/// it is to say they will avoid dynamic collisions. For fullfill this purpose
/// the MPG will use the validation function, to assure that all generated MPs
/// are valid.
class TMotionProgramGenerator : public TMotionProgramValidator,
        public TAllocationList {
protected:
    //-----------------------------------------------------------------------
    //SETTING PARAMETERS OF THE ALGORITHMS:

    double dt1Max;

    //-----------------------------------------------------------------------
    //METHODS FOR SEGREGATE SUBSETS OF RPs:
    
    /// @brief Segregate the RPs of the list Outsiders, in disjoint subsets.
    /// @param[in] Outsiders list of operative outsiders RPs tobe segregated.
    /// @param[out] DisjointSets list of disjoint sets.
    /// @pre All RPs in the list Outsiders:
    /// - shall be operative.
    /// - shall be in insecurity positions.
    void segregateRPsInDisjointSets(
            TPointersList<TRoboticPositionerList>& DisjointSets,
            const TRoboticPositionerList& Outsiders);

    /// @brief Determines if not all RPs of a list follow the MEGARA distribution.
    /// @param[in] Set disjoint set to check.
    /// @return true: if the RPs of the disjoint set follow a MEGARA distribution.
    /// @pre All RPs of the disjoint set:
    /// - shall be separated a distance D - 2*L or upper.
    bool notAllRPsFollowMEGARADistribution(
            const TRoboticPositionerList& Set);

    /// @brief Segregates the RPs of a set, in disperse subsets.
    /// @param[in] Set disjoint set to be splited.
    /// @param[out] Subsets list of disperse subsets.
    /// @pre Pointer Subsets should point to built list of disperse subsets.
    /// @pre All RPs of the list Set:
    /// - shall follow the MEGARA distribution.
    /// - shall be in the Fiber MOS Model.
    void segregateRPsInDisperseSubsets(
            TPointersList<TRoboticPositionerList > *Subsets,
            TRoboticPositionerList& Set);

    //-----------------------------------------------------------------------
    //METHODS FOR PROGRAM THE RPs AND SEGREGATE THE RECOVERABLES:

    /// @brief Determines if a pair of motion programs (MPturn, MPretraction)
    /// is incongruent. For this make the following action:
    /// @brief For the MPturn:
    /// - check if contains none or one message list
    /// - if the MPturn contains a message list:
    ///   * check if the message list contains one message instruction
    ///   * check if the message instruction is directed to a RP of the FMM
    ///   * check if the instruction is for turn the rotor 1
    /// @brief For the MPretraction:
    /// - check if contains one or two message list
    /// - check if in each message list:
    ///   * the message list contains one message instruction
    ///   * the message instruction is directed to a RP of the FMM
    /// - check if the first instruction is for retraction
    /// - check if the second instruction (if any) is for abatement
    /// @brief For the pair (MPturn, MPretraction):
    /// - check if all message instructions are directed to the same RP
    /// @param[in] (MPturn, MPretraction) the pair of MPs to check
    /// @param[out] RP the RP included in the pair (MPturn, MPretraction)
    /// when the pair is congruent
    /// @return true: if the pair is incongruent
    bool motionProgramsAreIncongruent(TRoboticPositioner* &RP,
                                const TMotionProgram& MPturn,
                                const TMotionProgram& MPretraction) const;

    /// @brief Determines if a pair of motion programs (MPturn, MPretraction)
    /// produces a colission.
    /// @pre All RPs of the Fiber MOS Model:
    /// - shall be configured for MP generation.
    /// @pre The pair (MPturn, MPretraction):
    /// - shall be congruent.
    /// @pre The RP included in the pair (MPturn, MPretraction):
    /// - shall has enabled the quantifiers of their rotors.
    /// @post If the MPretraction contains a single message list:
    /// - the single message list shall contains a single message
    /// - instruction for retract the arm.
    /// @post If the MPretraction contains two messages of instruction:
    /// - the first message list shall contains a single message
    /// - instruction for retract the arm,
    /// - and the second message list shall contains a single message
    /// - instruction for abate the arm.
    /// @param[in] (MPturn, MPretraction) the pair of MPs to validate
    /// @return true: if the pair avoid collisions
    bool motionProgramsAreValid(const TMotionProgram& MPturn,
                                const TMotionProgram& MPretraction) const;

    /// @brief Method motionProgramsAreValid not must restore the stacked
    /// positions, becuse the actual position could be diferent. So this method
    /// must stack the actual position and restore it.

    /// @brief Search in negative sense, the individual MP (composed by MPturn and
    /// MPretraction), for recover the security position of a RP
    /// avoiding dynamic collisions.
    /// @param[in] the robotic positioner to be recovered.
    /// @param[in] dt1max maximun displacement of the rotor 1 for search the solution
    /// in rad. Recomended value (M_PI/2).
    /// @param[out] p_1new last position where solution has been searched.
    /// @param[out] RP->MPturn the generated MP for turn the rotor 1 of the RP,
    /// to be executed in first place.
    /// @param[out] RP->MPretraction the generated MP for radial retraction,
    /// to be executed in second place.
    /// @return true: if the solution is valid.
    /// @pre All RPs of the Fiber MOS Model:
    /// - shall be configurated for MP generation.
    /// @pre The pointer RP:
    /// - shall point to built robotic positioner.
    /// @pre The RP:
    /// - shall be in the Fiber MOS  Model.
    /// - shall be in unsecurity position.
    /// - shall has enabled the quantifiers of their rotors.
    /// - shall not has dynamic collisions.
    /// - shall has stacked the actual positions of their rotors.
    /// @pre The length of the searching interval dt1max shall be upper zero.
    /// @post The RP will be in their initial status.
    /// @post If searchSolutionInNegativeSense == false:
    /// - solution p_1new will be nearest to
    /// max(RP->Actuator->theta_1first, theta_1 - dt1max).
    bool searchSolutionInNegativeSense(double& p_1new,TRoboticPositioner *RP,
                                       double dt1max);
    /// @brief Search in positive sense, the individual MP (composed by MPturn and
    /// MPretraction), for recover the security position of a RP
    /// avoiding dynamic collisions.
    /// @param[in] RP the robotic positioner to be recovered.
    /// @param[in] dt1max maximun displacement of the rotor 1 for search the solution
    /// in rad. Recomended value (M_PI/2).
    /// @param[out]  p_1new last position where solution has been searched.
    /// @param[out]  RP->MPturn the generated MP for turn the rotor 1 of the RP,
    /// to be executed in first place.
    /// @param[out] RP->MPretraction the generated MP for radial retraction,
    /// to be executed in second place.
    /// @return true: if the solution is valid.
    /// @pre  All RPs of the Fiber MOS Model:
    /// - shall be configurated for MP generation.
    /// @pre The pointer RP:
    /// - shall point to built robotic positioner.
    /// @pre The RP:
    /// - shall be in the Fiber MOS  Model.
    /// - shall be in unsecurity position.
    /// - shall has enabled the quantifiers of their rotors.
    /// - shall not has dynamic collisions.
    /// - shall has stacked the actual positions of their rotors.
    /// - The length of the searching interval dt1max shall be upper zero.
    /// @post The RP will be in their initial status.
    /// @post If searchSolutionInPositiveSense == false:
    /// - solution p_1new will be nearest to
    /// min(RP->Actuator->theta_1last, theta_1 + dt1max).
    bool searchSolutionInPositiveSense(double& p_1new, TRoboticPositioner *RP,
                                       double dt1max);
    /// @brief Search the best recoveery program for a individual RP.
    /// @param[in] RP the RP to be recovered.
    /// @param[out] RP->MPturn the generated MP for turn the rotor 1 of the RP,
    /// to be executed in first place.
    /// @param[out] RP->MPretraction the generated MP for radial retraction,
    /// to be executed in second place.
    /// @param[out] RP->Dsec security distance additional to SPM during retraction
    /// @return true: if the solution is valid.
    /// @pre The pointer RP shall point to built robotic positioner.
    /// @pre All RPs of the Fiber MOS Model:
    /// - shall be configurated for MP generation.
    /// @pre The RP:
    /// - shall be in the Fiber MOS  Model.
    /// - shall be in unsecurity position.
    /// - shall be enabled the quantifiers of their rotors.
    /// - shall not have dynamic collisions.
    /// - shall have stacked the actual positions of their rotors.
    /// @post The RP will be in their initial status, except their properties
    /// (MPturn, MPretraction, Dmin) which will contains the last proposal.
    bool searchSolution(TRoboticPositioner *RP);

    /// @brief Determines the RPs which can be recovered in each subset of each set.
    /// @param[in] DDS structure to contain disjoint disperse subsets.
    /// @param[out] RecoverablesDDS structure to contain the RPs which can be recovered.
    /// @param[out] UnrecoverablesDDS structure to contain the RPs which can not be recovered.
    /// @pre All RPs of the Fiber MOS Model:
    /// - shall be configurated for MP generation.
    /// @pre All RPs of DDS:
    /// - shall be in the Fiber MOS  Model.
    /// - shall be in unsecurity position.
    /// - shall be enabled the quantifiers of their rotors.
    /// - shall not have dynamic collisions.
    /// - shall have stacked the actual positions of their rotors.
    /// @post RecoverablesDDS will contains the RPs which can be recovered,
    /// programmedwith the necessary instruction for their recovery.
    /// @post All RPs of the RecoverablesDDS, will be in their initial  positions.
    /// UnrecoverablesDDS will contains the RPs which can not be recovered.
    /// @note It is not necessary that the RPs of DDS:
    /// - have stored their initial positions.
    /// - have disabled the quantifiers of their rotors.
    /// - have programmed any movement.
    void segregateRecoverables(
      TPointersList<TPointersList<TRoboticPositionerList> >& RecoverablesDDS,
      TPointersList<TPointersList<TRoboticPositionerList> >& UnrecoverablesDDS,
      TPointersList<TPointersList<TRoboticPositionerList> >& DDS);

    //-----------------------------------------------------------------------
    //METHODS FOR ADD MESSAGE LISTS TO A MP:

    /// @brief Add to a MP, the corresponding list or lists of message instruction
    /// correspondint to the individual MPs of the RPs of a RP list.
    /// @param[in] RPsToBeRetracted list of the RPs which has been programmed.
    /// @param[in, out] MP motion program to add themessage list.
    /// @pre All RPs of the list RPsToBeRetracted shall have stacked the starting
    /// positions of their rotors.
    /// @pre All RPs of the list RPsToBeRetracted shall be in their stacked positions.
    /// @pre All RPs of the list RPsToBeRetracted shall have a recovery program.
    void addMessageLists(TMotionProgram& MP,
                         const TRoboticPositionerList& RPsToBeRecovered);

    /// @brief Add to the DP the message-instruction list to move the RPs
    /// of the list Inners to the origins.
    /// @param[in] Inners list of operative RPs in seciry position out the origin.
    /// @param[out] DP depositioning program which the message list will be added.
    /// @pre All RPs of the list Inners shall be operatives in secure position
    /// but out the origin.
    void addMessageListToGoToTheOrigins(TMotionProgram& DP,
        const TRoboticPositionerList& Inners);

public:
    //-----------------------------------------------------------------------
    //SETTING PARAMETERS OF THE ALGORITHMS:

    //PARAMETERS TO GENERATE MPs:

    /// @brief get maximun displacement of the rotor 1 for search the solution
    double getdt1Max(void) const {return dt1Max;}
    /// @brief set maximun displacement of the rotor 1 for search the solution
    /// - must be nonnegative
    /// - default value: M_PI/2 rad
    void setdt1Max(double);

    //PARAMETERS TO REGENERATE MPs:

    /// @brief minimun number of reference sources in each CB
    /// - must be nonnegative
    /// - default value: 3
    unsigned int NRmin;
    /// @brief minimun number of blanksin each CB
    /// - must be nonnegative
    /// - default value: 1
    unsigned int NBmin;
    /// @brief maximun prioritywith mandatory allocation
    /// - must be upper zero
    /// - default value: 0
    unsigned int PrMax;

    //-----------------------------------------------------------------------
    //BUILDING AND DESTROYING METHODS:

    /// @brief build a motion program generator
    /// attached to a Fiber MOS Model
    TMotionProgramGenerator(TFiberMOSModel *FiberMOSModel);
    /// destroy the targetpoints and destroy the MPG
    ~TMotionProgramGenerator(void);

    //-----------------------------------------------------------------------
    //METHODS FOR GENERATE MPs:

    //Nomenclature:
    //
    //- DP (Depositioning Program): to go from the observing positions to the
    //  origins. It is generated using Purpose = pGenPairPPDP.
    //
    //- PP (Positioning Program): to go from the origins to the observing
    //  positions. It is the DP inverted int he time. It is generated
    //  using Purpose = pValDP.
    //
    //- Recovery Program: is a DP without the final gesture to go to the
    //  origins. It is generated to generate the DP.
    //
    //- Parking Program: to go from the actual positions to the
    //  origins. It is generated using Purpose = pGenPairPPDP.
    //
    //- IPL (Initial Position List): position of all RPs
    //  when PP is going to be executed.
    //
    //- OPL (Observing Position List): position of all RPs
    //  when DP is going to be executed.
    //
    //- SPL (starting Position List): position of all RPs
    //  when a recovery program is going to be generated
    //  or a ParkProg is going to be executed.

    //Note that all methods for generate motion programs, validate
    //the motion programs applying the function considered unerring:
    //  bool validateMotionProgram(TMotionProgram &MP) const;

    /// @brief Generates a recovery program for a given set of operative RPs
    /// in insecurity positions and determines the RPs of the given set,
    /// which can not be recovered because are in colliding status
    /// or because are obstructed in insecurity positions.
    /// @param[in] Outsiders list of operative RPs in unsecurity positions which
    /// we want recover the security positions.
    /// @param[out] Collided list of RPs collided in insecurity position.
    /// @param[out] Obstructed list of RPs obstructed in insecurity position.
    /// @param[out] RecoveryProgram the generated recovery program.
    /// @pre All RPs of the Fiber MOS Model:
    /// - shall be in their starting positions.
    /// - shall be configurated for MP generation.
    /// (Purpose == pGenPairPPDP || Purpose == pGenParPro).
    /// @pre All RPs of the list Outsiders:
    /// - shall be in the Fiber MOS Model.
    /// - shall be operatives.
    /// - shall be in insecurity positions.
    /// - shall have enabled the quantifiers of their rotors.
    /// @post All RPs of the Fiber MOS Model:
    /// - will be in the starting positions.
    /// - will have enabled the quantifiers.
    void generateRecoveryProgram(
        TRoboticPositionerList& Collided, TRoboticPositionerList& Obstructed,
        TMotionProgram& RecoveryProgram, const TRoboticPositionerList& Outsiders);

    /// @brief Generates a depositioning program for a given set of operative RPs
    /// in insecurity positions and determines the RPs of the given set,
    /// which can not be recovered because are in colliding status
    /// or because are obstructed in insecurity positions.
    /// @param[in] Outsiders list of operative RPs in unsecurity positions which
    /// we want recover the origin positions.
    /// @param[out] Collided list of RPs collided in insecurity position.
    /// @param[out] Obstructed list of RPs obstructed in insecurity position.
    /// @param[out] DP the generated depositioning program.
    /// @return true: if the generated DP is valid.
    /// @pre All RPs of the Fiber MOS Model:
    /// - shall be in their starting positions.
    /// @pre All RPs of the list Outsiders:
    /// - shall be in the Fiber MOS Model.
    /// - shall be operatives.
    /// - shall be in insecurity positions.
    /// - shall have enabled the quantifiers.
    /// - shall have velocity of rotor 2 approximately double than rotor 1.
    /// @post All RPs of the Fiber MOS Model:
    /// - will be configured for validate a DP. (Purpose == pValDP).
    /// @post When the generated depositioning program isn't valid:
    /// - All RPs of the FMM:
    ///   * will have disabled the quantifiers of their rotors.
    ///   * will be in the first position where the collision was detected
    ///   during the validation process.
    /// @post When the generated depositioning program is valid (even the trivial case):
    /// - All RPs of the FMM:
    ///   * will have enabled the quantifiers of their rotors.
    ///   * will be in their final positions.
    bool generateDepositioningProgram(
        TRoboticPositionerList& Collided, TRoboticPositionerList& Obstructed,
        TMotionProgram& DP, const TRoboticPositionerList& Outsiders);

    /// @brief Generates a positioning program from a given depositioning program.
    /// @param[in] DP depositioning program.
    /// @param[in] OPL observing position list.
    /// @param[out] PP the generated positioning program.
    /// @pre All RPs included in the OPL shall be in the FMM.
    /// @pre All RPs included in the DP shall be in the FMM.
    void generatePositioningProgram(TMotionProgram& PP,
        const TMotionProgram& DP, const TPairPositionAnglesList& OPL);

    /// @brief Generates a pair (PP, DP) for a given set of operative RPs
    /// in insecurity positions and determines the RPs of the given set,
    /// which can not be recovered because are in colliding status
    /// or because are obstructed in insecurity positions.
    /// @param[in] Outsiders list of operative RPs in unsecurity positions which
    /// we want move.
    /// @param[out] PPvalid flag indicating if the generated PP is valid.
    /// @param[out] DPvalid flag indicating if the generated DP is valid.
    /// @param[out] Collided list of RPs collided in insecurity position.
    /// @param[out] Obstructed list of RPs obstructed in insecurity position.
    /// @param[out] PP the generated positioning program.
    /// @param[out] DP the generated depositioning program.
    /// @pre All RPs of the Fiber MOS Model:
    /// - shall be in their observing positions.
    /// @pre All RPs of the list Outsiders:
    /// - shall be in the Fiber MOS Model.
    /// - shall be operatives.
    /// - shall be in insecurity positions.
    /// - shall have enabled the quantifiers.
    /// - shall have velocity of rotor 2 approximately double than rotor 1.
    /// @post All RPs of the Fiber MOS Model:
    /// - will be configured for validate a PP. (Purpose = pValPP).
    /// - will have disabled the quantifiers.
    /// @post When the generated pair (PP, DP) isn't valid:
    /// All RPs of the FMM:
    /// - will have disabled the quantifiers of their rotors.
    /// - will be in the first position where the collision was detected
    /// during the validation process.
    /// @post When the generated pair (PP, DP) is valid (even the trivial case):
    /// All RPs of the FMM:
    /// - will have enabled the quantifiers of their rotors.
    /// - will be in their initial positions.
    void generatePairPPDP(bool& PPvalid, bool& DPvalid,
        TRoboticPositionerList& Collided, TRoboticPositionerList& Obstructed,
        TMotionProgram& PP, TMotionProgram& DP,
        const TRoboticPositionerList& Outsiders);

    /// @brief Generates a parking program for a given set of operative RPs
    /// in insecurity positions and determines the RPs of the given set,
    /// which can not be recovered because are in colliding status
    /// or because are obstructed in insecurity positions.
    /// @param[in] Outsiders list of operative RPs in unsecurity positions which
    /// we want recover the security positions.
    /// @param[out] Collided list of RPs collided in insecurity position.
    /// @param[out] Obstructed list of RPs obstructed in insecurity position.
    /// @param[out] ParkProg the generated parking program.
    /// @return true: if the generated ParkProg is valid.
    /// @pre All RPs of the Fiber MOS Model:
    /// - shall be in their starting positions.
    /// @pre All RPs of the list Outsiders:
    /// - shall be in the Fiber MOS Model.
    /// - shall be operatives.
    /// - shall be in insecurity positions.
    /// - shall have enabled the quantifiers.
    /// @post All RPs of the FMM:
    /// - will be configured for validate a parking program.
    /// @post When the generated recovery program isn't valid:
    /// All RPs of the FMM:
    /// - will have disabled the quantifiers of their rotors.
    /// - will be in the first position where the collision was detected
    /// during the validation process.
    /// @post When the generated recovery program is valid (even the trivial case):
    /// All RPs of the FMM:
    /// - will have enabled the quantifiers of their rotors.
    /// - will be in their final positions.
    bool generateParkProg(
        TRoboticPositionerList& Collided, TRoboticPositionerList& Obstructed,
        TMotionProgram& ParkProg, const TRoboticPositionerList& Outsiders);

    //-----------------------------------------------------------------------
    //METHODS FOR REGENERATE MPs IN LIMITED SENSE:

    //Functions for attempt regenerate a pair (PP, DP) in limited sense
    //was developed for restrictive circunstances where the motion programs
    //can not be changed. For regenerate a pair (PP, DP) in not limited sense
    //use the same function for generate the pair (PP, DP) generatePairPPDP.

    // A not operative RP is a simple case if:
    // 1. The replacement RP exist and be available:
    //    a) The point to be observed (it is to say, the PP allocated to
    //    the RP to be replaced, and not the observing point of the RP),
    //    must be in the scope of other RP.
    // b) The adjacent RP, or some of their adjacents, must be operative
    // and not allocated.
    // 2. The unsecurity area of the replacement RP is clear
    // and will stay clear:
    //    a) The operative RPs adjacents to the replacement RP,
    //    are stopped in security area and if it has allocated a PP,
    //    this is in the security area.
    //    b) The not operative RPs adjacent to the replacement RP,
    //    are stopped non invading the maneuvering domain of
    //    the replacement RP. (This RPs could be allocated,
    //    and this set includes the RP to be replaced).

    /// @brief Search the replacement RPs of a RP
    /// @param[in] RP the RP to be replaced.
    /// @param[out] RRPs list of replacement RPs.
    /// @pre In the FMM:
    /// - All pointer of the Fiber MOS Model must point to built RPs.
    /// - All pointer of the fiber MOS Model must point to different RPs.
    /// - None operative RP of the Fiber MOS Model must has a dynamic fault.
    /// @pre In the RP:
    /// - Pointer RP must point to built robotic positioner.
    /// - The RP must be in the Fiber MOS Model.
    /// @pre In the TPL:
    /// - All RPs included in the TPL must be in the Fiber MOS Model.
    /// - All PPs included in the TPL must be in the scope of their allocated RP.
    /// - The RP must be included in the TPL.
    /// @post If the list RRPs is not empty, the RP is a simple case,
    /// and can be replaced by any of the replacement RPs.
    /// @post In other case the RP is not a simple case.
    void searchReplacementRPs(TRoboticPositionerList& RRPs,
                              const TRoboticPositioner *RP) const;

    //A PP is the type must when occur some of the following circunstances:
    //  1. Corresponds to a reference source, and the CB contains the minimun
    //     number of reference sources NRmin or less.
    //  2. Corresponds to a blank, and the CB contains the minimun
    //     number of blanks NBmin or less.
    //  3. Has a priority in [0, PrMax], and it is not allocated in other CB.
    //
    //The following circunstances will not be taken in account:
    //  4. Not has been allocated in other CB.
    //  5. Has been indicated that the point must be allocated in all CBs.

    //The FMOSA contains the following data by each observing source:
    //
    //SP properties:
    //string Name;        //name ("")                 (can be empty)
    //double RA;          //rect ascension (0)
    //double Dec;         //declination (0)
    //double Mag;         //magnitude (0)             (can be empty)
    //TPointType Type;    //type (ptUNKNOWN)
    //                    //{sptUNKNOWN, sptSOURCE, sptREFERENCE, sptBLANK}
    //Allocation properties
    //unsigned int Pr;    //allocation priority (0)   (can be empty)
    //unsigned int Bid;   //Id of the CB (0)          (can be empty)
    //unsigned int Pid;   //Id of the RP (0)
    //
    //PP properties:
    //double X;           //abcise (0)
    //double Y;           //ordinate (0)
    //bool Enabled;       //indicates if the point is allocated to the RP (false)
    //
    //Allocation properties:
    //string Comment;     //coment ("")               (can be empty)

    //The FMPT is interested in the following data by each point:
    //TSkyPointType Type; //type (sptUNKNOWN)
    //unsigned int Pr;    //allocation priority (0)   (can be empty)
    //unsigned int Bid;   //Id of the CB (0)          (can be empty)
    //unsigned int Pid;   //Id of the RP (0)
    //double X;           //abcise (0)
    //double Y;           //ordinate (0)
    //bool Enabled;       //indicates if the point is allocated to the RP (false)

    //If Enable==false, the allocation must be ignored.
    //All Bid must be equals each other.

    //From this information can be determined the following data:
    //  NR: number of reference sources in the CB.
    //  NB: number of blanks in the CB.

    //But for atempt regenerates a pair (PP, DP),
    //are necessary the following data:
    //  NRmin: minimun number of reference sources in the CB.
    //  NBmin: minimun number of blanks in the CB.
    //  PrMax: maximun priority with mandatory allocation.
    //      Points with priorities in [0, PrMax] have mandatory allocation.
    //  notAllocated: indicates that el point not has been allocated in other CB.
    //  allocateInAll: indicates if the point must be allocated in all CBs.

    //The data (NRmin, NBmin, PrMax) are the same for all points in the CB.
    //The data (noAllocated, allocateInAll) must be defined for each point.

    /// @brief Determines if an allocation if of must type.
    /// @param[in] i index to the allocation for determine if it is must type.
    /// @param[out] allocationIsMustType indicates if the allocation is of must type.
    /// @pre Index i should indicate to an allocation of this MPG.
    bool allocationIsMustType(int i) const;

    /// @brief Attempt regenerate a pair (PP, DP).
    /// @param[out] Excluded list of identifiers of the excluded RPs, if Any.
    /// @param[in, out] (PP, DP) the pair to regenerate.
    /// @return true: if the pair (PP, DP) has been regenerated.
    /// @pre All RPs included in the pair (PP, DP):
    /// - must be in the FMM.
    /// - must have one allocation in the MPG.
    /// @pre The status of the Fiber MOS Model:
    /// - must correspond to the status of the real Fiber MOS.
    /// @pre The allocations shall contains the properties enough to
    /// make the regeneration (Type, Pr, Pid, X, Y).
    bool attemptRegenerate(TVector<int>& Excluded,
                           TMotionProgram& PP, TMotionProgram& DP) const;
};

/*****************************************************************************
//FUNCTIONS TO BE USED ONLINE BY MCS (2015):

//Online functions are declared bellow. They can be summarized as follow:
//  ParkProgValid = generateParkProg_online(ParkProg, FMM, p_1s, p___3s, Ids);
//  PairPPDPValid = generatePairPPDP_online(PP, DP, FMM, p_1s, p___3s, Ids);

//Really all arguments of the online functions are included in the FMM,
//so argument p_1s, p___3s and Ids are innecessary. Furthermore these
//functions don't return neither Collided list nor Obstructed list,
//so it is not possible to know which RPs are collided or obstructed.
//These circunstances was warned to the programmer of the MCS, but he
//insisted do this in this way.

//Online generating functions has the following diferences respect
//the offline functions:
//   1. The online functions must have the FMM how argument, because
//      the instance of the FMM can't be loaded in this functions.
//
//   2. The messages indicating status of the process can't be printed
//      (neither in the standard output nor the log file).
//      So can't be warned the following circunstances:
//          If all operative outsider RPs are in the origins:
//              the generated motion program/s will be empty;
//          else, if there isn't operative outsider RPs:
//              the generated motion program/s will contains a single
//              message-instruction list,
//
//   3. The lists Collided and Obstructed are determined but they aren't returned.
//      Then could have collided or obstructed RPs, but it is not possible know
//      whiches.
//
//   4. The online functions include the list of RPs to be disabled.
//
//These are the reasons why is preferible implemt the offline functions
//at independ whay and not based on the online functions.

//Generates a parking program.
//Inputs:
//  FMM: the Fiber MOS Model.
//  p_1s: the rotor 1 starting positions of all RPs of the FMM.
//  p___3s: the rotor 2 starting positions of all RPs of the FMM.
//  Ids: the identifiers of the RPs of the FMM to be disabled.
//Outputs:
//  generateParkProg_online: indicates if the generated parking program is valid.
//  ParkProg: the parking program to be generated.
//Preconditions:
//  All operative outsider RPs of the FMM:
//    - shall be in the Fiber MOS Model;
//    - shall be operatives;
//    - shall be in insecurity positions;
//    - shall have enabled the quantifiers;
//  All position angles in the vector p_1s:
//    - must be in the rotor 1 domain of their corresponding RP.
//  All position angles in the vector p___3s:
//    - must be in the rotor 2 domain of their corresponding RP.
//  All identifiers in the vector Ids:
//    - must be referred to RPs in the FMM.
//Postconditions:
//  The RPs indicated in the list Ids will be disabled.
//  All RPs of the Fiber MOS Model will be configured for
//    - validate a parking program. (Purpose = valParPro).
//  When the generated recovery program isn't valid:
//      All RPs of the FMM:
//        - will have disabled the quantifiers of their rotors;
//        - will be in the first position where the collision was detected
//              during the validation process.
//  When the generated recovery program is valid (even in the trivial case):
//      All RPs of the FMM:
//        - will have enabled the quantifiers of their rotors;
//        - will be in their final positions.
bool generateParkProg_online(TMotionProgram& ParkProg,
    TFiberMOSModel& FMM,
    const vector<double>& p_1s, const vector<double>& p___3s,
    const vector<int>& Ids);

//Generates a pair (PP, DP).
//Inputs:
//  FMM: the Fiber MOS Model.
//  p_1s: the rotor 1 observing positions of all RPs of the FMM.
//  p___3s: the rotor 2 observing positions of all RPs of the FMM.
//  Ids: the identifiers of the RPs of the FMM to be disabled.
//Outputs:
//  generatePairPPDP_online: indicates if the generated pair (PP, DP) is valid.
//  PP: the positioning program to be generated.
//  DP: the depositioning program to be generated.
//Preconditions:
//  All operative outsider RPs of the FMM:
//    - shall be in the Fiber MOS Model;
//    - shall be operatives;
//    - shall be in insecurity positions;
//    - shall have enabled the quantifiers;
//  All position angles in the vector p_1s:
//    - must be in the rotor 1 domain of their corresponding RP.
//  All position angles in the vector p___3s:
//    - must be in the rotor 2 domain of their corresponding RP.
//  All identifiers in the vector Ids:
//    - must be referred to RPs in the FMM.
//Postconditions:
//  The RPs indicated in the list Ids will be disabled.
//  All RPs of the Fiber MOS Model will be configured for
//    - validate a PP. (Purpose = valPP).
//  When the generated pair (PP, DP) isn't valid:
//      All RPs of the FMM:
//        - will have disabled the quantifiers of their rotors;
//        - will be in the first position where the collision was detected
//              during the validation process.
//  When the generated pair (PP, DP) is valid (even in the trivial case):
//      All RPs of the FMM:
//        - will have enabled the quantifiers of their rotors;
//        - will be in their initial positions.
bool generatePairPPDP_online(TMotionProgram& PP, TMotionProgram& DP,
    TFiberMOSModel& FMM,
    const vector<double>& p_1s, const vector<double>& p___3s,
    const vector<int>& Ids);
*****************************************************************************/

//############################################################################
//FUNCTIONS TO BE USED ONLINE BY MCS (MARCH-MAY 2017)

//----------------------------------------------------------------------------
//DEEFINITIONS:

//A parking program is suitable to be executed when:
//1. The generated parking program has passed the validation
//   process, so it is safe that it not produces a dynamic collission.
//2. The FMM not contains enabled-not-operative RPs with dynamic fault.
//Note that could have either collided or obstructed RPs.

//A pair (PP, DP) is suitable to be executed when:
//1. The generated parking program has passed the validation
//   process, so it is safe that it not produces a dynamic collission.
//2. The FMM not contains enabled-not-operative RPs with dynamic fault.
//3. The FMM not contains neither collided nor obstructed RPs.

//----------------------------------------------------------------------------
//PREDECLARATIONS:

class OutputsParkProg;
class OutputsPairPPDP;

//----------------------------------------------------------------------------
//FMM AND OUTPUTS IN STRUCTURE FORMAT:

/// @brief Generate a parking program online.
/// @param[in] FMM the Fiber MOS Model
/// @param[in] p_1s the rotor 1 starting positions of all RPs of the FMM.
/// @param[in] p___3s the rotor 2 starting positions of all RPs of the FMM.
/// @param[in] RPids the identifiers of the RPs of the FMM to be disabled.
/// @param[out] outputs
/// @return true: if the generated parking program is suitable to be executed.
bool generateParkProg_online(OutputsParkProg& outputs,
        TFiberMOSModel& FMM,
        const vector<double>& p_1s, const vector<double>& p___3s,
        const vector<int>& RPids, const unsigned int Bid);

/// @brief Generate a pair (PP, DP) online.
/// @param[in] FMM the Fiber MOS Model
/// @param[in] p_1s the rotor 1 observing positions of all RPs of the FMM.
/// @param[in] p___3s the rotor 2 observing positions of all RPs of the FMM.
/// @param[in] RPids the identifiers of the RPs of the FMM to be disabled.
/// @param[out] outputs structure OutputsPairPPDP (without FMOSA).
/// @return true: if the generated pair (PP, DP) is suitable to be executed.
bool generatePairPPDP_online(OutputsPairPPDP& outputs,
        TFiberMOSModel& FMM,
        const vector<double>& p_1s, const vector<double>& p___3s,
        const vector<int>& RPids, const unsigned int Bid);

//----------------------------------------------------------------------------
//FMM IN STRING FORMAT AND OUTPUTS IN STRUCTURE FORMAT:

/// @brief Generate a parking program online.
/// @param[in] FMMI_dir dir of the FMM Instance
/// @param[in] p_1s the rotor 1 starting positions of all RPs of the FMM.
/// @param[in] p___3s the rotor 2 starting positions of all RPs of the FMM.
/// @param[in] RPids the identifiers of the RPs of the FMM to be disabled.
/// @param[out] outputs structure OutputsParkProg.
/// @return true: if the generated parking program is suitable to be executed.
bool generateParkProg_online(OutputsParkProg& outputs,
        const string& FMMI_dir,
        const vector<double>& p_1s, const vector<double>& p___3s,
        const vector<int>& RPids, const unsigned int Bid);

/// @brief Generate a pair (PP, DP) online
/// @param[in] FMMI_dir dir of the FMM Instance
/// @param[in] p_1s the rotor 1 observing positions of all RPs of the FMM.
/// @param[in] p___3s the rotor 2 observing positions of all RPs of the FMM.
/// @param[in] RPids the identifiers of the RPs of the FMM to be disabled.
/// @param[out] outputs structure OutputsPairPPDP (without FMOSA).
/// @return true: if the generated pair (PP, DP) is suitable to be executed.
bool generatePairPPDP_online(OutputsPairPPDP& outputs,
        const string& FMMI_dir,
        const vector<double>& p_1s, const vector<double>& p___3s,
        const vector<int>& RPids, const unsigned int Bid);

//----------------------------------------------------------------------------
//FMM AND OUTPUTS IN STRING FORMAT:

/// @brief Generate a parking program online
/// @param[in] FMMI_dir dir of the FMM Instance
/// @param[in] p_1s the rotor 1 starting positions of all RPs of the FMM.
/// @param[in] p___3s the rotor 2 starting positions of all RPs of the FMM.
/// @param[in] RPids the identifiers of the RPs of the FMM to be disabled.
/// @param[in] Bid identifier of the block.
/// @param[out] outputs_str structure OutputsParkProg in format string.
/// @return true: the generated parking program is suitable to be executed.
bool generateParkProg_online(string& outputs_str,
        const string& FMMI_dir,
        const vector<double>& p_1s, const vector<double>& p___3s,
        const vector<int>& RPids, const unsigned int Bid);

/// @brief Generate a pair (PP, DP) online
/// @param[in] FMMI_dir dir of the FMM Instance
/// @param[in] p_1s the rotor 1 observing positions of all RPs of the FMM.
/// @param[in] p___3s the rotor 2 observing positions of all RPs of the FMM.
/// @param[in] RPids the identifiers of the RPs of the FMM to be disabled.
/// @param[in] Bid identifier of the block.
/// @param[out] outputs_str structure OutputsPairPPDP in format string (without FMOSA).
/// @return true: the generated pair (PP, DP) is suitable to be executed.
bool generatePairPPDP_online(string& outputs_str,
        const string& FMMI_dir,
        const vector<double>& p_1s, const vector<double>& p___3s,
        const vector<int>& RPids, const unsigned int Bid);

//----------------------------------------------------------------------------
//Precondition and their exceptions:
//  EImproperCall       locale information shall be set to minimal C locale
//      (you can make this calling "setlocale(LC_ALL, "C");")
//  EImproperFileLoadedValue: directory FMMI_dir shall contains
//      a valid FMM Instance.
//  EImproperArgument   vector p_1s should has one position
//      for each RP of the FMM
//  EImproperArgument   vector p___3s should has one position
//      for each RP of the FMM
//  EImproperArgument   all position angles indicated in (p_1, p___3)
//      shall be in the domain of their respectives rotors of the RPs
//  EImproperArgument   vector RPids shall contains exclusively
//      RP's identifiers of the FMM
//
//Exceptions EImproperFileLoadedValue will start with: "writing instance: "
//All exception are dervied from "Excetion" which is derived from "exception".
//
//Posconditions:
//  The stored FMM Instance can be changed.
//So maybe you need administrator provileges for execute these functions.

//----------------------------------------------------------------------------
//WARNING!
//
//In function generateParkProg_online:
//- if in the FMM there are enabled-not-operative RPs, will be generated
//  with an initial uncommented note for difficult their execution.
//- both collided and obstructed RPs will be excluded from
//  the generated parking program.
//
//In function generatePairPPDP_online:
//- if in the FMM there are enabled not operative RPs, will be generated
//  with an initial uncommented note for difficult their execution.
//- both collided and obstructed RPs shall be disabled, because
//  the pair (PP, DP) can't be re-generated including either
//  collided or obstructed RPs.
//
//So in functions online, it is responsability of the user, determine the RPs
//to be disabled, and to be conscious of the RPs icluded in the generated MPs.
//
//For determine the list of RPs included in a generated parking program
//or a re-generated pair (PP, DP), you can use the following functions:
//
//  //Get the list of RPs included in a MP.
//  //Precondition:
//  //  All message of instruction in the MP shall be addressed
//  //  to an existent RP of the Fiber MOS Model.
//  void getRPsIncludedInMP(TRoboticPositionerList& RPL,
//                          const TMotionProgram& MP,
//                          const TFiberMOSModel *FMM);
//
//  //Get the list of RPs included in a pair of MPs.
//  //Precondition:
//  //  All message of instruction in the MPs shall be addressed
//  //  to an existent RP of the Fiber MOS Model.
//  void getRPsIncludedInMPs(TRoboticPositionerList& RPL,
//                       const TMotionProgram& MP1, const TMotionProgram& MP2,
//                       const TFiberMOSModel *FMM);
//
//For use this functions maybe you need include 'MotionProgramValidator.h'.

//############################################################################

} //namespace Positioning

//---------------------------------------------------------------------------
#endif // MOTIONPROGRAMGENERATOR_H
