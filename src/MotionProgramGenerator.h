// Copyright (c) 2014-2015 Isaac Morales Durán. All rights reserved.
// Institute of Astrophysics of Andalusia, IAA-CSIC
//
// This file is part of FMPT (Fiber MOS Positioning Tools)
//
// FMPT is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program.  If not, see <http://www.gnu.org/licenses/>.

//---------------------------------------------------------------------------
//File: MotionProgramGenerator.h
//Content: generator of motionprograms
//Last update: 26/12/2014
//Author: Isaac Morales Durán
//---------------------------------------------------------------------------

#ifndef MOTIONPROGRAMGENERATOR_H
#define MOTIONPROGRAMGENERATOR_H

#include "MotionProgramValidator.h"
#include "TargetPointList.h"
#include "SPPP.h"
#include "FiberMOSModel2.h"
#include "MotionProgram.h"

//---------------------------------------------------------------------------

using namespace Models;

//namespace for positioning
namespace Positioning {

//###########################################################################
//TMotionProgramGenerator:
//###########################################################################

//A MPG (Motion Program Generator) provide functions to generates MPs (motion
//programs). For this, the MPG shall be use the Fiber MOS Model to perform
//simulations. All MPs  generated by the MPG will be valid, is to say they
//will avoid dynamic collisions. For accomplish of this purpose the MPG
//will make use of the validator function, to assure that the generation
//process is valid. Each MP shall go with an IPL (Initial Position List)
//of type TPairsPositionAngleList.

//class motion program generator
class TMotionProgramGenerator : public TMotionProgramValidator,
        public TTargetPointList {
protected:
    //-----------------------------------------------------------------------
    //SETTING PARAMETERS OF THE ALGORITHMS:

    double p_MSD;

    //-----------------------------------------------------------------------
    //METHODS OF LOWER LEVEL:

    //Segregate the RPs of the list Outsiders, in disjoint subsets.
    //Preconditions:
    //  All RPs in the list Outsiders shall be operatives
    //  All RPs in the list Outsiders shall be in insecurity positions
    void segregateRPsInDisjointSets(
            TPointersList<TRoboticPositionerList>& DisjointSets,
            const TRoboticPositionerList& Outsiders);

    //Determines if not all RPs of a list follow the MEGARA distribution.
    //Preconditions:
    //  All RPs of the disjoint set shall be separated
    //  a distance D - 2*L or upper.
    bool notAllRPsFollowMEGARADistribution(
            const TRoboticPositionerList& Set);

    //Segregates the RPs of a set, in disperse subsets.
    //Preconditions:
    //  Pointer Subsets should point to built list of disperse subsets.
    //  All RPs of the list Set shall follow the MEGARA distribution.
    //  All RPs in the list Set shall be in the Fiber MOS Model.
    void segregateRPsInDisperseSubsets(
            TPointersList<TRoboticPositionerList > *Subsets,
            TRoboticPositionerList& Set);

    //-----------------------------------------------------------------------

    //Propose a recovery program composed by one or two gestures:
    //  1. Radial retraction to where it is possible.
    //  2. Abatement of the arm to security position (if necessary).
    //Input:
    //  RP: The RP containing the properties (MPturn, MPretraction).
    //Outputs:
    //  RP->MPturn: motion program for turn the rotor 1.
    //  RP->MPretraction: motionprogram for retract the arm.
    //Preconditions:
    //- Pointer RP shall point to built robotic positioner.
    //- The RP shall be enabled the quantifiers of their rotors.
    //- The RP shall be in unsecurity position.
    //Postconditions:
    //- The RP->MPturn will be empty.
    //- The RP->MPretraction will contains the MP for retract the arm
    //  to the first stable security position.
    void proposeRecoveryProgram(TRoboticPositioner *RP);
    //Propose a recovery program composed by one or two gestures:
    //  1. Radial retraction to where it is possible.
    //  2. Abatement of the arm to security position (if necessary).
    //Input:
    //  RP: the RP containing the properties (MPturn, MPretraction).
    //  p_1new: the position to turn the rotor 1 of the RP.
    //Outputs:
    //  RP->MPturn: motion program for turn the rotor 1.
    //  RP->MPretraction: motionprogram for retract the arm.
    //Preconditions:
    //- Pointer RP shall point to built robotic positioner.
    //- The RP shall be enabled the quantifiers of their rotors.
    //- The RP shall be in unsecurity position.
    //- The new rotoe 1 position p_1new shall be in the rotor 1 domain.
    //Postconditions:
    //- The RP->MPturn will contains the MP for turn the rotor 1
    //  to the position p_1new.
    //- The RP->MPretraction will contains the MP for retract the arm
    //  to the first stable security position.
    void proposeRecoveryProgram(TRoboticPositioner *RP, double p_1new);

    //Determines if a motion program produces a colission,
    //Preconditions:
    //- All RPs of the Fiber MOS Model:
    //      shall be configured for MP generation;
    //      shall be enabled the quantifiers of their rotors;
    //      shall has stacked the actual position of their rotors.
    //- The motion programs (MPturn, MPretraction) shall be valids.
    //  If the MP contains a single message list:
    //      the single message instruction shall be for retract the arm.
    //  If the MPcontains twomessages of onstruction,
    //      the first message instruction shall be for turn the rotor 1,
    //      and the second message instruction shall be for retract the arm.
    bool motionProgramsAreValid(const TMotionProgram& MPturn,
                              const TMotionProgram& MPretraction) const;

    //Search in negative sense, the individual MP for recover the security
    //position of a RP avoiding dynamic collisions.
    //Inputs:
    //  RP: robotic positioner to be recovered.
    //  dt1max: maximun displacement of the rotor 1 for search the solution
    //      in rad.
    //Outputs:
    //  searchSolutionInNegativeSense: indicates if the solution is valid.
    //  p_1new: last position where solution has been searched.
    //  (RP->MPturn, RP->MPretraction): the solution.
    //Preconditions:
    //  All RPs of the Fiber MOS Model shall be configurated for MP generation.
    //  The pointer RP shall shall point to built robotic positioner.
    //  The RP:
    //      shall be in the Fiber MOS  Model;
    //      shall be in unsecurity position;
    //      shall be enabled the quantifiers of their rotors;
    //      shall not have dynamic collisions;
    //      shall have stacked the actual positionsof their rotors.
    //  The length of the searching interval dt1max shall be upper zero.
    //Postconditions:
    //  The RP will be in their initial status.
    //  If searchSolutionInNegativeSense == false
    //      solution p_1new will be nearest to
    //      Max(RP->Actuator->theta_1first, theta_1 - dt1max).
    bool searchSolutionInNegativeSense(double& p_1new,TRoboticPositioner *RP,
                                       double dt1max);
    //Search in positive sense, the individual MP for recover the security
    //position of a RP avoiding dynamic collisions.
    //Inputs:
    //  RP: robotic positioner to be recovered.
    //  dt1max: maximun displacement of the rotor 1 for search the solution
    //      in rad.
    //Outputs:
    //  searchSolutionInPositiveSense: indicates if the solution is valid.
    //  p_1new: last position where solution has been searched.
    //  (RP->MPturn, RP->MPretraction): the solution.
    //Preconditions:
    //  All RPs of the Fiber MOS Model shall be configurated for MP generation.
    //  The pointer RP shall shall point to built robotic positioner.
    //  The RP:
    //      shall be in the Fiber MOS  Model;
    //      shall be in unsecurity position;
    //      shall be enabled the quantifiers of their rotors;
    //      shall not have dynamic collisions;
    //      shall have stacked the actual positionsof their rotors.
    //  The length of the searching interval dt1max shall be upper zero.
    //Postconditions:
    //  The RP will be in their initial status.
    //  If searchSolutionInPositiveSense == false
    //      solution p_1new will be nearest to
    //      Max(RP->Actuator->theta_1last, theta_1 + dt1max).
    bool searchSolutionInPositiveSense(double& p_1new, TRoboticPositioner *RP,
                                       double dt1max);
    //Search the best recoveery program for a RP.
    //Inputs:
    //  RP: the RP to be recovered.
    //Outputs:
    //  searchSolution: indicates if the solution is valid.
    //  (RP->MPturn, RP->MPretraction): the recovery program.
    //  RP->Dsec: security distance additional to SPM during retraction
    //Preconditions:
    //  The pointer RP shall shall point to built robotic positioner.
    //  All RPs of the Fiber MOS Model shall be configurated for MP generation.
    //  The RP:
    //      shall be in the Fiber MOS  Model;
    //      shall be in unsecurity position;
    //      shall be enabled the quantifiers of their rotors;
    //      shall not have dynamic collisions;
    //      shall have stacked the actual positionsof their rotors.
    //Postconditions:
    //  The RP will be in their initial status, except the properties
    //  (MPturn, MPretraction, Dmin) which will contains the last proposal.
    bool searchSolution(TRoboticPositioner *RP);

    //Determines the RPs which can be recovered in each subset of each set.
    //Inputs:
    //  DDS: structure to contain disjoint disperse subsets.
    //Outputs:
    //  RecoverablesDDS: structure to contain the RPs which can be recovered.
    //  UnrecoverablesDDS: structure to contain the RPs which can not be recovered.
    //Preconditions:
    //  All RPs of the Fiber MOS Model shall be configurated for MP generation.
    //  All RPs of DDS:
    //      shall be in the Fiber MOS  Model;
    //      shall be in unsecurity position;
    //      shall be enabled the quantifiers of their rotors;
    //      shall not have dynamic collisions;
    //      shall have stacked the actual positionsof their rotors.
    //Postconditions:
    //  RecoverablesDDS will contains the RPs which can be recovered,
    //  programmedwith the necessary instruction for their recovery.
    //  All RPs of the RecoverablesDDS, will be in their initial  positions.
    //  UnrecoverablesDDS will contains the RPs which can not be recovered.
    //Notes:
    //  It is not necessary that the RPs of DDS have stored their initial
    //  positions.
    //  It is not necessary that the RPs of DDS have disabled the quantifiers
    //  of their rotors.
    //  It is not necessary that the RPs of DDS have programmed any movement.
    void segregateRecoverables(
      TPointersList<TPointersList<TRoboticPositionerList> >& RecoverablesDDS,
      TPointersList<TPointersList<TRoboticPositionerList> >& UnrecoverablesDDS,
      TPointersList<TPointersList<TRoboticPositionerList> >& DDS);

    //-----------------------------------------------------------------------

    //Add to a MP, the corresponding list or lists of message instruction
    //correspondint to the individual MPs of the RPs of a RPlist
    //Inputs:
    //  RPsToBeRetracted: list of the RPs which has been programmed.
    //  MP: motion program to add themessage list.
    //Outputs:
    //  MP: motion program modified.
    //Preconditions:
    //  All RPs of the list RPsToBeRetracted shall have stacked the initial
    //      positions of their rotors.
    //  All RPs of the list RPsToBeRetracted shall be in their stacked positions.
    //  All RPs of the list RPsToBeRetracted shall have a recovery program.
    void addMessageLists(TMotionProgram& MP,
                         const TRoboticPositionerList& RPsToBeRecovered);

    //Add to the DP the message-instruction list to move the RPs
    //of the list Inners to the origins
    //Inputs:
    //  Inners: list of operative RPs in seciry position out the origin.
    //Output:
    //  DP: depositioning program which the message list will be added.
    //Preconditions:
    //  All RPs of the list Inners shall be operatives in secure position
    //  but out the origin.
    void addMessageListToGoToTheOrigins(TMotionProgram& DP,
        const TRoboticPositionerList& Inners);

public:
    //-----------------------------------------------------------------------
    //SETTING PARAMETERS OF THE ALGORITHMS:

    //PARAMETERS TO GENERATE PAIRS (PP, DP):

    //maximun security distance between RPs during radial retraction
    //this is additional to the SPM
    //must be nonnegative
    //default value: 1 mm
    double getMSD(void) const {return p_MSD;}
    void setMSD(double);

    //PARAMETERS TO REGENRATE PAIRS (PP, DP):

    //minimun number of reference sources in each CB
    //must be nonnegative
    //default value: 3
    unsigned int NRmin;
    //minimun number of blanksin each CB
    //must be nonnegative
    //default value: 1
    unsigned int NBmin;
    //maximun prioritywith mandatory allocation
    //must be upper zero
    //default value: 0
    unsigned int PrMax;

    //-----------------------------------------------------------------------
    //BUILDING AND DESTROYING METHODS:

    //build a motion program generator
    //attached to a robotic positionerlist
    TMotionProgramGenerator(TFiberMOSModel *FiberMOSModel);
    //destroy the targetpoints and destroy the MPG
    ~TMotionProgramGenerator(void);

    //-----------------------------------------------------------------------
    //METHODS TO GENERATE MPs:

    //Nomenclature:
    //- Positioning Program: to go the observing positiong, need has a first
    //  gesture to go to the starting positions in the secure area.
    //- Depositioning Program: antagonicus of PP, include a final gesture
    //  tomove therotors to their origins.
    //- Recovery Program: is a DP without the final gesture to go to the
    //  origins.
    //- Parking Gesture: gesture to mo the rotors to their origins.

    //Generates a recovery program for a given set of operative RPs
    //in insecurity positions and determines the RPs of the given set,
    //which can not be recovered because are in collision status
    //or because are obstructed in insecurity positions.
    //Preconditions:
    //  All RPs of the Fiber MOS Model, shall be in their initial positions.
    //  All RPs of the list Outsiders:
    //      shall be in the Fiber MOS Model;
    //      shall be operatives;
    //      shall be in insecurity positions;
    //      shall have enabled the quantifiers of their rotors;
    //      shall be setted in order to the rotor 2 velocity
    //          is approximately double than rotor 1 velocity.
    //Postconditions:
    //  All RPs of the FMM will be configured for MP validation.
    //  When the generated recovery program isn't valid:
    //      All RPs of the FMM:
    //          will have disabled the quantifiers of their rotors;
    //          will be in the first position where the collision was detected
    //              during the validation process.
    //  When the generated recovery program is valid (even the trivial case):
    //      All RPs of the FMM:
    //          will have enabled the quantifiers of their rotors;
    //          will be in their final positions.
    //Inputs:
    //  FMM: Fiber MOS Model with RPs in their initial positions.
    //  Outsiders: list of operative RPs in unsecurity positions which
    //      we want recover the security positions.
    //Outputs:
    //  generateRecoveryProgram: flag indicating if the recovery program
    //      generated with this function is valid.
    //  Collided: list of RPs collided in insecurity position.
    //  Obstructed: list of RPs obstructed in insecurity position.
    //  MP: recovery program.
    bool generateRecoveryProgram(TRoboticPositionerList& Collided,
        TRoboticPositionerList& Obstructed, TMotionProgram& MP,
        const TRoboticPositionerList& Outsiders);

    //Generates a depositioning program for a given set of operative RPs
    //in insecurity positions and determines the RPs of the given set,
    //which can not be recovered because are in collision status
    //or because are obstructed in insecurity positions.
    //Preconditions:
    //  All RPs of the Fiber MOS Model, shall be in their initial positions.
    //  All RPs of the list Outsiders, shall be in the Fiber MOS Model.
    //  All RPs of the list Outsiders, shall be operatives.
    //  All RPs of the list Outsiders, shall be in insecurity positions.
    //  All RPs of the list Outsiders, shall have enabled the quantifiers.
    //  All RPs of the list Outsiders, shall have a rotor 2 velocity
    //  approximately double that rotor 1 velocity.
    //Postconditions:
    //  All RPs of the Fiber MOS Model will be configured for MP validation
    //  All RPs of the fiber MOS Model will be in their final positions,
    //  or the first position where the collision was detected.
    //  All RPs of the Fiber MOS Model will have disabled the quantifiers.
    //Inputs:
    //  FiberMOSModel: Fiber MOS Model with RPs in their initial positions.
    //  Outsiders: list of operative RPs in unsecurity positions which
    //      we want recover the security positions.
    //Outputs:
    //  generateParkingProgram: flag indicating if the parking program
    //      can be generated or not with this function.
    //  Collided: list of RPs collided in insecurity position.
    //  Obstructed: list of RPs obstructed in insecurity position.
    //  DP: depositioning program.
    bool generateDepositioningProgram(TRoboticPositionerList& Collided,
        TRoboticPositionerList& Obstructed, TMotionProgram& DP,
        const TRoboticPositionerList& Outsiders);

    //Generates a positioning program from a given depositioning program.
    void generatePositioningProgram(TMotionProgram& PP,
        const TMotionProgram& DP, const TPairPositionAnglesList& IPL);

    //Generates a pair (PP, DP) for a given set of operative RPs
    //in insecurity positions and determines the RPs of the given set,
    //which can not be recovered because are in collision status
    //or because are obstructed in insecurity positions.
    //Preconditions:
    //  All RPs of the Fiber MOS Model, shall be in their observing positions.
    //  All RPs of the list Outsiders, shall be in the Fiber MOS Model.
    //  All RPs of the list Outsiders, shall be operatives.
    //  All RPs of the list Outsiders, shall be in insecurity positions.
    //  All RPs of the list Outsiders, shall have enabled the quantifiers.
    //Postconditions:
    //  All RPs of the Fiber MOS Model will be configured for MP validation
    //  All RPs of the fiber MOS Model will be in their final positions,
    //  or the first position where the collision was detected.
    //  All RPs of the Fiber MOS Model will have disabled the quantifiers.
    //Inputs:
    //  FiberMOSModel: Fiber MOS Model with RPs in their observing positions.
    //  Outsiders: list of operative RPs in unsecurity positions which
    //      we want recover the security positions.
    //Outputs:
    //  generateParkingProgram: flag indicating if the pair (PP, DP)
    //      can be generated or not with this function.
    //  Collided: list of RPs collided in insecurity position.
    //  Obstructed: list of RPs obstructed in insecurity position.
    //  PP: positioning program.
    //  DP: depositioning program.
    bool generatePairPPDP(TRoboticPositionerList& Collided,
        TRoboticPositionerList& Obstructed, TMotionProgram& PP,
        TMotionProgram& DP, const TRoboticPositionerList& Outsiders);

    //-----------------------------------------------------------------------

    //A not operative RP is a simple case if:
    //1. The replacement RP exist and be available:
    //   a) The point to be observed (it is to say, the PP allocated to
    //      the RP to be replaced, and not the observing point of the RP),
    //      must be in the scope of other RP.
    //   b) The adjacent RP, or some of their adjacents, must be operative
    //      and not allocated.
    //2. The unsecurity area of the replacement RP is clear
    //   and will stay clear:
    //   a) The operative RPs adjacents to the replacement RP,
    //      are stopped in security area and if it has allocated a PP,
    //      this is in the security area.
    //   b) The not operative RPs adjacent to the replacement RP,
    //      are stopped non invading the maneuvering domain of
    //      the replacement RP. (This RPs could be allocated,
    //      and this set includes the RP to be replaced).

    //search the replacement RPs of a RP
    //Inputs:
    //  RP: the RP to be replaced.
    //Outputs:(
    //  RPRs: list of replacement RPs.
    //Preconditions of the FMM:
    //- All pointer of the Fiber MOS Model must point to built RPs.
    //- All pointer of the fiber MOS Model must point to different RPs.
    //- None operative RP of the Fiber MOS Model must has a dynamic fault.
    //Preconditions of the RP:
    //- Pointer RP must point to built robotic positioner.
    //- The RP must be in the Fiber MOS Model.
    //Preconditions of the TPL:
    //- All RPs included in the TPL must be in the Fiber MOS Model.
    //- All PPs included in the TPL must be in the scope of their allocated RP.
    //- The RP must be included in the TPL.
    //Postconditions:
    //- If the list RPRs is not empty, the RP is a simple case,
    //  and can be replaced by any of the replacement RPs.
    //  In other case the RP is not a simple case.
    void searchReplacementRPs(TRoboticPositionerList& RPRs,
                              const TRoboticPositioner *RP) const;

    //A PP is the type must when occur some of the following circunstances:
    //  1. Corresponds to a reference source, and the CB contains the minimun
    //     number of reference sources NRmin or less.
    //  2. Corresponds to a blank, and the CB contains the minimun
    //     number of blanks NBmin or less.
    //  3. Has a priority in [0, PrMax], and it is not allocated in other CB.
    //  4. Not has been allocated in other CB.
    //  5. Has been indicated that the point must be allocated in all CBs.

    //The SPPP list contains the following data by each point:
    //
    //SP properties:
    //string Name;        //name ("")                 (can be empty)
    //double RA;          //rect ascension (0)
    //double Dec;         //declination (0)
    //double Mag;         //magnitude (0)             (can be empty)
    //TPointType Type;    //type (ptUNKNOWN)
    //                    //{sptUNKNOWN, sptSOURCE, sptREFERENCE, sptBLANK}
    //Allocation properties
    //unsigned int Pr;    //allocation priority (0)   (can be empty)
    //unsigned int Bid;   //Id of the CB (0)          (can be empty)
    //unsigned int Pid;   //Id of the RP (0)
    //
    //PP properties:
    //double X;           //abcise (0)
    //double Y;           //ordinate (0)
    //bool Enabled;       //indicates if the point is allocated to the RP (false)
    //
    //Allocation properties:
    //string Comment;     //coment ("")               (can be empty)

    //The FMPT is interested in the following data by each point:
    //TSkyPointType Type; //type (sptUNKNOWN)
    //unsigned int Pr;    //allocation priority (0)   (can be empty)
    //unsigned int Bid;   //Id of the CB (0)          (can be empty)
    //unsigned int Pid;   //Id of the RP (0)
    //double X;           //abcise (0)
    //double Y;           //ordinate (0)
    //bool Enabled;       //indicates if the point is allocated to the RP (false)

    //If Enable==false, the allocation must be ignored.
    //All Bid must be equals each other.

    //From this information can be determined the following data:
    //  NR: number of reference sources in the CB.
    //  NB: number of blanks in the CB.

    //But for atempt regenerates a pair (PP, DP),
    //are necessary the following data:
    //  NRmin: minimun number of reference sources in the CB.
    //  NBmin: minimun number of blanks in the CB.
    //  PrMax: maximun priority with mandatory allocation.
    //      Points with priorities in [0, PrMax] have mandatory allocation.
    //  notAllocated: indicates that el point not has been allocated in other CB.
    //  allocateInAll: indicates if the point must be allocated in all CBs.

    //The data (NRmin, NBmin, PrMax) are the same for all points in the CB.
    //The data (noAllocated, allocateInAll) must be defined for each point.

    //Determines if an allocation if of must type.
    //Inputs:
    //  i: index to the allocation for determine if it is must type.
    //Outputs:
    //  allocationIsMustType: indicates if the allocation is of must type.
    //Preconditions:
    //- Index i should indicate to an allocation of this MPG.
    bool allocationIsMustType(int i) const;

    //Attempt regenerate a pair (PP, DP).
    //Inputs:
    //- (PP, DP): the pair to regenerate.
    //Outputs:
    //- attemptRegenerate: flag indicating if the pair (PP, DP)
    //  has been regenerated.
    //- (PP, DP): the regenerated pair, if any.
    //- Excluded: list of identifiers of the excluded RPs, if Any.
    //Preconditions:
    //- All RPs included in the pair (PP, DP):
    //  must be in the FMM;
    //  must have an allocation in the MPG.
    //- The status of the Fiber MOS Model must correspond to
    //  the status of the real Fiber MOS.
    //- The allocations shall contains the properties enough to
    //  make the regeneration (Type, Pr, Pid, X, Y).
    bool attemptRegenerate(TVector<int>& Excluded,
                           TMotionProgram& PP, TMotionProgram& DP) const;
};

//---------------------------------------------------------------------------

} //namespace Positioning

//---------------------------------------------------------------------------
#endif // MOTIONPROGRAMGENERATOR_H
